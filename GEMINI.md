# Gemini Code Exploration Report

This document provides a comprehensive overview of the `memU` project, generated by the Gemini CLI.

## Project Overview

`memU` is a sophisticated, dual-language memory framework designed for the development of 24/7 proactive AI agents. The project's primary goal is to facilitate the creation of long-running, "always-on" agents that can continuously learn from interactions and proactively assist users, while minimizing the token costs associated with Large Language Models (LLMs).

The framework is architected as a Python library with a core Rust extension for performance-critical components, leveraging the `pyo3` and `maturin` build system. This hybrid approach combines the ease of use of Python with the performance and safety of Rust.

`memU` offers both a cloud-based and a self-hosted deployment option, providing flexibility for different use cases. It supports a variety of LLM and embedding providers, including OpenAI and OpenRouter, and can be integrated with different database backends like PostgreSQL (with `pgvector` for vector similarity search) and an in-memory option for testing and development.

The core functionalities of `memU` are exposed through two main APIs:

*   `memorize()`: A continuous learning pipeline that processes various data modalities (conversations, documents, images, etc.) in real-time and updates the agent's memory.
*   `retrieve()`: A dual-mode intelligence system that supports both fast, RAG-based context assembly and deeper, LLM-based anticipatory reasoning.

The project is well-documented, with a comprehensive `README.md` file, example usage scripts, and a clear hierarchical memory architecture.

## Building and Running

The project uses `uv` for Python package management and `maturin` for building the Rust extension. The `Makefile` provides a set of convenient commands for development and testing.

### Setting up the Development Environment

To set up the development environment, run the following command:

```bash
make install
```

This command will create a virtual environment, install all the necessary dependencies (including those for development and testing), and set up pre-commit hooks for code quality checks.

### Running Tests

To run the test suite, use the following command:

```bash
make test
```

This will execute the `pytest` test runner and generate a coverage report. The project has a comprehensive test suite that covers the core functionalities, including in-memory, PostgreSQL, and OpenRouter integrations.

### Running Quality Checks

To ensure code quality and adherence to the project's standards, run:

```bash
make check
```

This command will perform a series of checks, including linting, static type analysis, and dependency verification.

### Running Examples

The `examples/` directory contains several scripts that demonstrate the usage of `memU`. To run them, you first need to set up your environment variables (e.g., `OPENAI_API_KEY`) and then execute the desired script. For instance, to run the basic conversation memory example:

```bash
export OPENAI_API_KEY='your_api_key'
python examples/example_1_conversation_memory.py
```

## Development Conventions

The `memU` project adheres to a set of modern development conventions to ensure code quality, consistency, and maintainability.

### Code Formatting and Linting

The project uses `ruff` for code formatting and `pre-commit` to automatically enforce a consistent code style. The `ruff` configuration is defined in `pyproject.toml` and is set to fix most issues automatically.

### Static Type Checking

`mypy` is used for static type checking, which helps to catch potential errors before runtime. The `mypy` configuration in `pyproject.toml` is strict, requiring type hints for all function definitions.

### Testing

The project has a strong emphasis on testing. The `tests/` directory contains a comprehensive suite of tests that are run with `pytest`. The tests cover different aspects of the framework, including integrations with various databases and LLM providers.

### Dependency Management

The project uses `uv` to manage Python dependencies and `cargo` for the Rust part. The `pyproject.toml` file clearly separates production and development dependencies, and the `deptry` tool is used to identify and remove obsolete dependencies.

### Versioning and Changelog

The project seems to use a `CHANGELOG.md` file to keep track of changes between versions.

### Contribution Guidelines

The `CONTRIBUTING.md` file (referenced in the `README.md`) likely contains detailed instructions for contributors, including branching strategy, commit message format, and pull request process.
